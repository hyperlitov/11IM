# Matrix.cpp — документация

Краткое описание
- Реализация класса `Matrix` для операций с матрицами (создание, доступ к элементам, арифметика, транспонирование, определитель, обратная матрица и т.д.).
- Предполагает использование современного C++ (C++11/C++17+).

Требования
- Компилятор: g++, clang++ или MSVC.
- Стандарт: C++11 или выше.

Сборка
- Пример (g++):
    ```
    g++ -std=c++17 Matrix.cpp main.cpp -o app
    ```
- Для проектов CMake: включите `Matrix.cpp` в список исходников.

API (обзор)
- Конструкторы
    - `Matrix(size_t rows, size_t cols)` — создать матрицу заданного размера, элементы инициализируются нулями.
    - `Matrix(std::initializer_list<std::initializer_list<double>> init)` — инициализация из вложенного списка.
- Деструктор — освобождение ресурсов по RAII.
- Размеры
    - `size_t rows() const`
    - `size_t cols() const`
- Доступ к элементам
    - `double& operator()(size_t i, size_t j)`
    - `double operator()(size_t i, size_t j) const`
    - Проверка границ должна выбрасывать исключение (`std::out_of_range`) при неверных индексах.
- Арифметика
    - `Matrix operator+(const Matrix& other) const`
    - `Matrix operator-(const Matrix& other) const`
    - `Matrix operator*(const Matrix& other) const` — матричное умножение (с проверкой совместимости размеров).
    - `Matrix operator*(double scalar) const` и `Matrix operator/(double scalar) const`
    - Операторы присвоения `+=`, `-=`, `*=`
- Специальные методы
    - `Matrix transpose() const` — транспонирование.
    - `double determinant() const` — определитель (обычно для квадратных матриц, иначе — исключение).
    - `Matrix inverse() const` — обратная матрица (выбрасывает исключение при вырожденной или не квадратной матрице).
    - `Matrix identity(size_t n)` — статический метод для единичной матрицы.
- Вспомогательное
    - `std::string toString() const` — текстовое представление (для отладки).
    - Возможна оптимизация копированием/перемещением: реализованы move-конструктор и move-assign.

Поведение и исключения
- Методы, требующие квадратной матрицы (определитель, обратная), должны проверять и выбрасывать `std::invalid_argument` или `std::runtime_error`.
- Деление на ноль (скалярного) должно выбрасывать `std::domain_error` или подобное.
- Операции с несовместимыми размерами — `std::invalid_argument`.

Примеры использования
- Простая программа:
    ```cpp
    #include "Matrix.h" // или объявление класса в Matrix.cpp/h
    #include <iostream>

    int main() {
            Matrix A{{1, 2}, {3, 4}};
            Matrix B(2, 2);
            B(0,0) = 5; B(0,1) = 6;
            B(1,0) = 7; B(1,1) = 8;

            Matrix C = A * B;
            std::cout << "C =\n" << C.toString() << "\n";

            try {
                    double det = A.determinant();
                    std::cout << "det(A) = " << det << "\n";
                    Matrix invA = A.inverse();
                    std::cout << "A^-1 =\n" << invA.toString() << "\n";
            } catch (const std::exception& e) {
                    std::cerr << "Ошибка: " << e.what() << "\n";
            }
            return 0;
    }
    ```

Тесты
- Рекомендуется покрыть тестами:
    - Конструкторы и доступ к элементам.
    - Операции сложения/умножения/вычитания на согласованных и несогласованных размерах.
    - Вычисление определителя и обратной матрицы для известных примеров.
    - Пограничные случаи: нулевые, единичные, вырожденные матрицы.
- Используйте GoogleTest или Catch2 для автоматизации.

Производительность
- Для больших матриц рекомендуется:
    - Использовать эффективное хранение (одномерный вектор).
    - Избегать лишних копий (реализовать move-семантику).
    - При необходимости — блокирование и кеш-ориентированные алгоритмы или использование BLAS.

Лицензия и вклад
- Укажите лицензию проекта (например, MIT/Apache/BSD) в корне репозитория.
- Инструкция для вклада: форк → ветка → pull request, линтер и тесты перед PR.

Контакты
- Описание автора/поддержки и инструкции по открытию issue.

Следующие шаги
- Добавить заголовочный файл (Matrix.h) с описанием интерфейса.
- Написать модульные тесты и примеры использования в examples/.
- Оптимизировать критичные операции (умножение, вычисление обратной) при необходимости.