# Matrix — API, behavior и руководство

Файл: Matrix.cpp  
Реализует классическую маленькую библиотеку для работы с матрицами в C++:
- базовый класс `Matrix`
- производный класс квадратных матриц `Sq_Matrix`
- вектор-строка `Row_Vector` и вектор-столбец `Col_Vector`
- операторы арифметики, транспонирование, определитель, обратная матрица
- демонстрационный `main` с примерами использования


---

Содержание
- Краткое резюме
- Требования и сборка
- Классы и публичный API
  - Matrix
  - Sq_Matrix
  - Row_Vector / Col_Vector
- Поведение методов и возвращаемые значения
- Исключения / ошибки
- Примеры использования
- Сложность алгоритмов
- Рекомендации по улучшению и refactor
- Тестирование
- Лицензия / заметки

---

Краткое резюме
-------------
Matrix.cpp — самодостаточный .cpp файл с реализацией (без отдельного заголовка). Реализует динамические двумерные матрицы на основе `std::vector<std::vector<float>>`. Большинство операций возвращают новые объекты (не меняют исходник). Для ошибок используется бросание C-style строк (`throw "..."`).

Требования и сборка
-------------------
- Компилятор: любой, поддерживающий C++11 (используются `<vector>`, `<cmath>` и т.д.)
- Команда сборки (пример, WSL/MinGW):
  - g++ Matrix.cpp -o matrix -std=c++11
  - ./matrix
- Файл main уже встроен и запускает примеры.

Публичный API / классы
----------------------

1) Класс Matrix
- Поля (protected):
  - int row, col — размеры
  - std::vector<std::vector<float>> values — данные
- Конструкторы:
  - Matrix(int r, int c, float number = 0.)
    - Создаёт r×c, заполненную `number`.
  - Matrix(int r, int c, std::vector<float> data)
    - Заполняет матрицу построчно из одномерного вектора длины r*c.
    - Если `data.size() != r*c` — бросает исключение: `"Data size does not match matrix size"`.
  - Matrix(int r, int c, std::vector<std::vector<float>> data)
    - Примает уже организованный 2D-вектор; проверяет размеры (data.size()==r и data[0].size()==c).
    - В случае несоответствия — бросает `"Data size does not match matrix size"`.

- Методы / операторы:
  - Matrix operator + (const Matrix& M)
    - Поэлементное сложение. Если размеры не совпадают — бросает `"Matrices dimensions don't match for addition"`.
  - Matrix operator + (const float& num)
    - Добавление скаляра к каждому элементу.
  - Matrix operator - (const Matrix& M)
    - Поэлементное вычитание. При несовпадении размеров — бросает соответствующую строку.
  - Matrix operator - (const float& num)
    - Вычитание скаляра.
  - Matrix operator * (const Matrix& M)
    - Матричное умножение. Требует this->col == M.row, иначе бросает `"Matrix's size doesn't match for multiplication"`.
  - Matrix operator * (const float& num)
    - Умножение на скаляр.
  - Matrix operator - ()
    - Унарный минус (смена знака всех элементов).
  - Matrix T()
    - Транспонирование (возвращает новую матрицу размера col×row).
  - void print()
    - Печать матрицы в stdout, построчно через `std::cout`.
  - getRow(), getCol()
    - Возвращают размеры.
- Защищённые вспомогательные:
  - float det()
    - Рекурсивный расчёт детерминанта (разложение по первой строке).
    - Проверяет квадратность; если не квадрат — бросает `"Matrix must be square to calculate determinant"`.
  - Matrix inverse()
    - Вычисляет обратную матрицу через матрицу алгебраических дополнений (cofactor) и `det()`.
    - Если матрица не квадратная — бросает `"Matrix must be square for inverse"`.
    - Если детерминант 0 — бросает `"Error! det = 0"`.

2) Класс Sq_Matrix : public Matrix
- Конструкторы удобны: принимают `size` и данные; используют `Matrix(size,size,...)`.
- Sq_Matrix(const Matrix& m)
  - Копирующий конструктор: если `m` не квадратная — бросает `"Matrix must be square!"`.
- Публичные-обёртки:
  - float det() — вызывает защищённый `Matrix::det()`.
  - Sq_Matrix inverse(), operator!() — возвращают квадратную обратную матрицу (используют Matrix::inverse()).

3) Row_Vector и Col_Vector
- Row_Vector(int size, std::vector<float> data) : Matrix(1,size,data)
- Col_Vector(int size, std::vector<float> data) : Matrix(size,1,data)
- Метод float abs() — возвращает евклидову норму (sqrt(sum squares)). Бросает строку при внутреннем несоответствии размеров (защитная проверка).

Поведение методов и возвращаемые значения
----------------------------------------
- Большинство операций возвращают новый объект `Matrix` (копируют данные).
- Методы не отмечены `const` (например `T()` и `print()` не const-заявлены) — это стоит исправить.
- `det()` рекурсивно создаёт подматрицы; для n×n имеет экспоненциальную сложность в худшем случае.
- `inverse()` использует вычисление алгебраических дополнений и детерминанта — очень неэффективно для больших матриц.

Исключения / ошибки
-------------------
- В текущем коде ошибки сообщаются через `throw "some message"` (C-string). Это неудобно для точной обработки и небезопасно.
- Рекомендуется заменить на стандартные исключения: `throw std::invalid_argument("...")` или свои типы-наследники `std::runtime_error`.
- Основные сообщения:
  - "Data size does not match matrix size"
  - "Matrices dimensions don't match for addition/subtraction"
  - "Matrix's size doesn't match for multiplication"
  - "Matrix must be square to calculate determinant"
  - "Matrix must be square for inverse"
  - "Error! det = 0"
  - "Matrix must be square!"

Примеры использования
---------------------
- В файле уже есть пример `main()` с набором тестов:
  - создание матриц разными конструкторами
  - операции +, -, *, умножение на скаляр
  - транспонирование, детерминант и обратная матрица через `Sq_Matrix`
  - векторы `Row_Vector` и `Col_Vector` и их `abs()`

Короткий пример:
```cpp
Matrix A(2,2, std::vector<std::vector<float>>{{1,2},{3,4}});
Matrix B = A + 1.0f;
Matrix C = A * B.T();
Sq_Matrix S(A);
float d = S.det();
Sq_Matrix inv = S.inverse();
```

Сложность алгоритмов
--------------------
- Сложность сложения/вычитания/скалярного умножения: O(r*c)
- Матричное умножение: O(r * col * M.col) — кубическая для квадратных матриц (наивный алгоритм)
- det() (разложение по минору): O(n!) / O(n * (n-1)!) — экспоненциальная, практически невозможна для n > 10
- inverse() через минора/кофакторов — требует n вызовов det для (n-1)x(n-1) и т.д., сверхдорого

Рекомендации по улучшению
-------------------------
Код функционален, но есть крупные точки улучшения:

1. Исключения
   - Заменить `throw "..."` на `throw std::invalid_argument(...)` или `std::runtime_error`.
   - Ловить `std::exception` в `main`.

2. const-correctness
   - Объявить методы, которые не меняют объект, как `const`:
     - Matrix T() const;
     - void print() const;
     - Matrix operator+(...) const; и т.д.

3. Разделение на header / impl
   - Создать `Matrix.h` с классами и `Matrix.cpp` с реализациями — улучшит читаемость и ускорит сборку при изменениях.

4. Эффективный детерминант и обратная
   - Реализовать LU-разложение (или Gauss с частичным выбором главного элемента) для детерминанта и обратной матрицы — O(n^3).
   - При использовании LU: вычисление det = product of U diagonal elements * sign.

5. Проверки и конструктор копирования
   - Явно объявить/определить copy/move конструкторы и операторы присваивания (Rule of 0/3/5).
   - Сделать конструкторы принимающими `const std::vector<...>&` (сейчас уже по значению — копирование лишнее).

6. Память и производительность
   - Избегать `std::vector<std::vector<...>>` для плотных матриц; лучше один вектор размера r*c и индексирование values[i*c + j].
   - Это улучшит кеш-производительность и уменьшит количество аллокаций.

7. Интерфейс
   - Добавить методы доступа `at(i,j)` и операторы `operator()(i,j)` для более удобной работы.
   - Добавить `operator==`/`operator!=`.

8. Тесты
   - Добавить набор unit-тестов (Catch2 / GoogleTest) на небольшие матрицы: сложение, умножение, det для 1..5, обратная матрица и проверка A * A^{-1} ~ I с epsilon.

9. Неблокирующие улучшения
   - Сделать сообщения об ошибках более информативными (включая размеры матриц).
   - Не использовать `using namespace std;` в заголовках.

10. Документация и примеры
   - Добавить README (этот файл), примеры и краткий benchmark (время для разных n).

Тестирование и проверка
----------------------
- Тест 1: Проверить базовые операции 2×2, 3×3
- Тест 2: Инвариант обратной: A * A^{-1} ≈ I (с учетом float eps)
- Тест 3: Обработка ошибок: несоответствующая длина входного вектора — бросок исключения
- Тест 4: Пограничные случаи: нулевая матрица, единичная матрица, вырожденная матрица (det=0)

Полезные заметки
----------------
- Текущий `det()` и `inverse()` подходят только для учебных небольших матриц (n ≤ 6…8).
- Для чисел с плавающей запятой сравнивайте с эпсилон при проверках равенства нулю.
- `Row_Vector::abs()` и `Col_Vector::abs()` возвращают евклидову норму.

Пример улучшений (фрагменты)
----------------------------
- Сделать конструктор более безопасным:
```cpp
Matrix(int r, int c, const std::vector<float>& data) {
    if (data.size() != size_t(r*c)) throw std::invalid_argument("...");
    values.reserve(r);
    // ...
}
```
- Использовать LU для inverse:
  - Реализовать `lu_decompose()` возвращающую `L`,`U`,`P` и использовать их далее.
